name: 'Joomla Extension Packager'
description: 'A composite action to package and release Joomla extensions (modules, plugins, components)'
author: 'N6REJ'

branding:
    icon: 'package'
    color: 'blue'

inputs:
    # Extension identification
    extension-name:
        description: 'Extension folder and file prefix (e.g. mod_example, plg_system_example). If not specified, derived from repository name'
        required: false
        default: ''
    extension-xml:
        description: 'Main XML file (e.g. mod_example.xml). If not specified, derived from extension name'
        required: false
        default: ''
    extension-type:
        description: 'Type of extension (module, plugin, component). If not specified, derived from repository name prefix.'
        required: false
        default: ''

    # Author and copyright
    author:
        description: 'Author name or handle. If not specified, uses the repository owner.'
        required: false
        default: ''
    copyright-holder:
        description: 'Copyright string (e.g. YourName (YourHandle))'
        required: false
        default: ''
    copyright-start-year:
        description: 'Copyright start year'
        required: false
        default: ''

    # Version control
    github-token:
        description: 'GitHub token for authentication'
        required: true
    manual-version:
        description: 'Manual version override (e.g. 1.2.3). If not specified, uses automatic date-based versioning'
        required: false
        default: ''

    # PHP configuration
    php-version:
        description: 'PHP version to use'
        required: false
        default: '8.1'

    # File configurations
    changelog-file:
        description: 'Changelog filename'
        required: false
        default: 'CHANGELOG.md'
    helper-file:
        description: 'Helper PHP file'
        required: false
        default: 'helper.php'
    license-file:
        description: 'License file'
        required: false
        default: 'License.txt'
    favicon-file:
        description: 'Favicon file (leave empty to skip)'
        required: false
        default: 'favicon.ico'
    updates-xml-file:
        description: 'Updates XML file'
        required: false
        default: 'updates.xml'

    # Directory configurations
    css-dir:
        description: 'CSS directory'
        required: false
        default: 'css'
    js-dir:
        description: 'JS directory'
        required: false
        default: 'js'
    tmpl-dir:
        description: 'Template directory'
        required: false
        default: 'tmpl'
    language-dir:
        description: 'Language directory'
        required: false
        default: 'language'
    package-dir:
        description: 'Package output directory (always uses build/)'
        required: false
        default: 'build'

    # Additional features
    dir-tree-file:
        description: 'Directory tree output file (leave empty to skip)'
        required: false
        default: 'directory-structure.txt'
    file-updates:
        description: 'Whether to update version and copyright in files'
        required: false
        default: 'true'
    generate-changelog:
        description: 'Whether to generate changelog from commits'
        required: false
        default: 'true'
    create-release:
        description: 'Whether to create a GitHub release'
        required: false
        default: 'true'
    upload-artifact:
        description: 'Whether to upload as GitHub artifact'
        required: false
        default: 'true'
    update-joomla-server:
        description: 'Whether to update Joomla update server XML'
        required: false
        default: 'true'
    readme:
        description: 'Include README.md in the package (true/false)'
        required: false
        default: 'false'

outputs:
    version:
        description: 'The generated version number'
        value: ${{ steps.set_version.outputs.version }}
    creation-date:
        description: 'The creation date'
        value: ${{ steps.set_version.outputs.creation_date }}
    package-path:
        description: 'Path to the created package'
        value: ${{ steps.create_package.outputs.package_path }}
    release-url:
        description: 'URL of the created release'
        value: ${{ steps.create_release.outputs.url }}
    dir-tree-path:
        description: 'Path to the directory tree file'
        value: ${{ steps.create_package.outputs.dir_tree_path }}

runs:
    using: 'composite'
    steps:
        -   name: Determine extension details
            id: extension_details
            shell: bash
            run: |
                # Get repository name
                REPO_NAME="${{ github.event.repository.name }}"
                echo "Repository name: $REPO_NAME"
                
                # Determine extension name
                if [ -n "${{ inputs.extension-name }}" ]; then
                  EXTENSION_NAME="${{ inputs.extension-name }}"
                  echo "Using provided extension name: $EXTENSION_NAME"
                else
                  # Derive from repository name
                  # Common patterns: mod_example, mod-example, mod.example, example-module
                  EXTENSION_NAME="$REPO_NAME"
                
                  # Replace common separators with underscores
                  EXTENSION_NAME="${EXTENSION_NAME//-/_}"
                  EXTENSION_NAME="${EXTENSION_NAME//./_}"
                
                  # Check if it already has a valid Joomla prefix
                  if [[ ! "$EXTENSION_NAME" =~ ^(mod_|plg_|com_) ]]; then
                    # Add prefix based on extension type
                    case "${{ inputs.extension-type }}" in
                      module)
                        EXTENSION_NAME="mod_${EXTENSION_NAME}"
                        ;;
                      plugin)
                        # For plugins, we need to determine the group
                        # Default to system if not clear from name
                        if [[ "$EXTENSION_NAME" =~ (system|content|user|authentication|search|editor|captcha|finder|installer|quickicon) ]]; then
                          EXTENSION_NAME="plg_${EXTENSION_NAME}"
                        else
                          EXTENSION_NAME="plg_system_${EXTENSION_NAME}"
                        fi
                        ;;
                      component)
                        EXTENSION_NAME="com_${EXTENSION_NAME}"
                        ;;
                    esac
                  fi
                
                  # Remove common suffixes if they exist
                  EXTENSION_NAME="${EXTENSION_NAME%_module}"
                  EXTENSION_NAME="${EXTENSION_NAME%_plugin}"
                  EXTENSION_NAME="${EXTENSION_NAME%_component}"
                
                  echo "Derived extension name: $EXTENSION_NAME"
                fi
                
                # Determine XML file
                if [ -n "${{ inputs.extension-xml }}" ]; then
                  EXTENSION_XML="${{ inputs.extension-xml }}"
                  echo "Using provided XML file: $EXTENSION_XML"
                else
                  # Derive from extension name
                  EXTENSION_XML="${EXTENSION_NAME}.xml"
                  echo "Derived XML file: $EXTENSION_XML"
                fi
                
                # Validate that the XML file exists
                if [ ! -f "$EXTENSION_XML" ]; then
                  echo "::warning::XML file not found at expected location: $EXTENSION_XML"
                  echo "Looking for XML files in the repository..."
                
                  # Try to find any XML file that might be the manifest
                  XML_FILES=$(find . -maxdepth 1 -name "*.xml" -not -name "updates.xml" -not -name "config.xml" | head -5)
                
                  if [ -n "$XML_FILES" ]; then
                    echo "Found XML files:"
                    echo "$XML_FILES"
                
                    # If only one XML file found, use it
                    XML_COUNT=$(echo "$XML_FILES" | wc -l)
                    if [ "$XML_COUNT" -eq 1 ]; then
                      EXTENSION_XML=$(echo "$XML_FILES" | head -1 | sed 's|^\./||')
                      echo "Using found XML file: $EXTENSION_XML"
                    else
                      echo "::error::Multiple XML files found. Please specify the extension-xml input."
                      exit 1
                    fi
                  else
                    echo "::error::No XML manifest file found. Please specify the extension-xml input."
                    exit 1
                  fi
                fi
                
                # Output the determined values
                echo "extension_name=$EXTENSION_NAME" >> $GITHUB_OUTPUT
                echo "extension_xml=$EXTENSION_XML" >> $GITHUB_OUTPUT
                
                echo "Final extension details:"
                echo "  Name: $EXTENSION_NAME"
                echo "  XML: $EXTENSION_XML"

        -   name: Set up PHP
            uses: shivammathur/setup-php@v2
            with:
                php-version: ${{ inputs.php-version }}

        -   name: Generate version and dates
            id: set_version
            shell: bash
            run: |
                CREATION_DATE=$(date +'%Y %B %d')
                CURRENT_YEAR=$(date +'%Y')
                
                # Check if manual version is provided
                if [ -n "${{ inputs.manual-version }}" ]; then
                  VERSION="${{ inputs.manual-version }}"
                  echo "Using manual version: $VERSION"
                else
                  # Use automatic date-based versioning
                  BASE_VERSION=$(date +'%Y.%m.%d')
                  git fetch --tags
                  if git rev-parse "$BASE_VERSION" >/dev/null 2>&1; then
                    MATCHING_TAGS=$(git tag -l "$BASE_VERSION.*")
                    if [ -z "$MATCHING_TAGS" ]; then
                      VERSION="${BASE_VERSION}.1"
                    else
                      HIGHEST_SUBVERSION=$(echo "$MATCHING_TAGS" | sed "s/^$BASE_VERSION\\.//" | sort -n | tail -1)
                      NEXT_SUBVERSION=$((HIGHEST_SUBVERSION + 1))
                      VERSION="${BASE_VERSION}.$NEXT_SUBVERSION"
                    fi
                  else
                    VERSION="$BASE_VERSION"
                  fi
                  echo "Using automatic version: $VERSION"
                fi
                
                echo "version=$VERSION" >> $GITHUB_OUTPUT
                echo "creation_date=$CREATION_DATE" >> $GITHUB_OUTPUT
                echo "current_year=$CURRENT_YEAR" >> $GITHUB_OUTPUT

        -   name: Update extension XML manifest
            if: inputs.file-updates == 'true'
            shell: bash
            run: |
                EXTENSION_XML="${{ steps.extension_details.outputs.extension_xml }}"
                VERSION="${{ steps.set_version.outputs.version }}"
                CREATION_DATE="${{ steps.set_version.outputs.creation_date }}"
                CURRENT_YEAR="${{ steps.set_version.outputs.current_year }}"
                
                # Function to update XML file
                update_xml_file() {
                  local XML_FILE="$1"
                  if [ -f "$XML_FILE" ]; then
                    echo "Updating version in $XML_FILE to $VERSION"
                    cp "$XML_FILE" "${XML_FILE}.bak"
                    
                    # Update version tag
                    sed -i "s|<version>.*</version>|<version>$VERSION</version>|g" "$XML_FILE"
                    
                    # Update creation date if present
                    sed -i "s|<creationDate>.*</creationDate>|<creationDate>$CREATION_DATE</creationDate>|g" "$XML_FILE"
                    
                    # Update copyright year if present
                    if [ -n "${{ inputs.copyright-holder }}" ]; then
                      if [ -n "${{ inputs.copyright-start-year }}" ] && [ "$CURRENT_YEAR" -gt "${{ inputs.copyright-start-year }}" ]; then
                        sed -i "s|<copyright>.*</copyright>|<copyright>Copyright (C) ${{ inputs.copyright-start-year }} - $CURRENT_YEAR ${{ inputs.copyright-holder }}</copyright>|g" "$XML_FILE"
                      else
                        sed -i "s|<copyright>.*</copyright>|<copyright>Copyright (C) $CURRENT_YEAR ${{ inputs.copyright-holder }}</copyright>|g" "$XML_FILE"
                      fi
                    fi
                    
                    # Remove backup file
                    rm -f "${XML_FILE}.bak"
                    
                    echo "Updated $XML_FILE with version $VERSION"
                    echo "Version line in XML:"
                    grep "<version>" "$XML_FILE" || echo "No version tag found"
                  else
                    echo "::warning::XML file not found: $XML_FILE"
                  fi
                }
                
                # Update main extension XML
                update_xml_file "$EXTENSION_XML"
                
                # Check if this is a package extension
                if [ -f "$EXTENSION_XML" ] && grep -q 'type="package"' "$EXTENSION_XML"; then
                  echo "Package extension detected. Updating referenced extension XML files..."
                  
                  # Extract referenced directories and IDs from the package manifest
                  # The <file> tags contain directory paths, not XML file paths
                  # Format:
                  # <file type="module" id="mod_test">mod_test</file>
                  # <file type="plugin" group="content" id="plg_content_test">plugins/content/test</file>
                  # <file type="component" id="com_test">com_test</file>
                  
                  # Parse each <file> tag to get the directory and ID
                  while IFS= read -r line; do
                    if [[ "$line" =~ \<file[^\>]*id=\"([^\"]+)\"[^\>]*\>([^\<]+)\</file\> ]]; then
                      EXT_ID="${BASH_REMATCH[1]}"
                      EXT_DIR="${BASH_REMATCH[2]}"
                      
                      echo "Processing extension: $EXT_ID in directory: $EXT_DIR"
                      
                      # Determine the XML filename based on the ID
                      # For plugins, the XML might be named differently
                      if [[ "$EXT_ID" =~ ^plg_ ]]; then
                        # Plugin XML files are often named after the plugin name without the group
                        # e.g., plg_task_bears_aichatbot -> bears_aichatbot.xml
                        PLUGIN_NAME="${EXT_ID#plg_*_}"
                        # Try both naming conventions
                        POSSIBLE_XML_NAMES=(
                          "${EXT_ID}.xml"
                          "${PLUGIN_NAME}.xml"
                          "$(basename "$EXT_DIR").xml"
                        )
                      else
                        # For modules and components, the XML is usually named after the ID
                        POSSIBLE_XML_NAMES=(
                          "${EXT_ID}.xml"
                          "$(basename "$EXT_DIR").xml"
                        )
                      fi
                      
                      # Try to find the XML file
                      FOUND=false
                      for XML_NAME in "${POSSIBLE_XML_NAMES[@]}"; do
                        XML_PATH="${EXT_DIR}/${XML_NAME}"
                        if [ -f "$XML_PATH" ]; then
                          echo "Found and updating: $XML_PATH"
                          update_xml_file "$XML_PATH"
                          FOUND=true
                          break
                        fi
                      done
                      
                      if [ "$FOUND" = false ]; then
                        echo "::warning::Could not find XML manifest for $EXT_ID in $EXT_DIR"
                        echo "Tried: ${POSSIBLE_XML_NAMES[*]}"
                      fi
                    fi
                  done < "$EXTENSION_XML"
                fi

        -   name: Update Joomla update server XML
            if: inputs.update-joomla-server == 'true'
            shell: bash
            run: |
                EXTENSION_NAME="${{ steps.extension_details.outputs.extension_name }}"
                UPDATES_XML="${{ inputs.updates-xml-file }}"
                DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/${{ steps.set_version.outputs.version }}/${EXTENSION_NAME}_${{ steps.set_version.outputs.version }}.zip"
                # If updates.xml does not exist, create a minimal valid structure
                if [ ! -f "$UPDATES_XML" ]; then
                  echo '<?xml version="1.0" encoding="utf-8"?>' > "$UPDATES_XML"
                  echo '<updates>' >> "$UPDATES_XML"
                  echo '  <update>' >> "$UPDATES_XML"
                  echo '    <name>'"$EXTENSION_NAME"'</name>' >> "$UPDATES_XML"
                  echo '    <description />' >> "$UPDATES_XML"
                  echo '    <element>'"$EXTENSION_NAME"'</element>' >> "$UPDATES_XML"
                  echo '    <type />' >> "$UPDATES_XML"
                  echo '    <version>${{ steps.set_version.outputs.version }}</version>' >> "$UPDATES_XML"
                  echo '    <infourl />' >> "$UPDATES_XML"
                  echo '    <downloads>' >> "$UPDATES_XML"
                  echo '      <downloadurl type="full" format="zip">'"$DOWNLOAD_URL"'</downloadurl>' >> "$UPDATES_XML"
                  echo '    </downloads>' >> "$UPDATES_XML"
                  echo '  </update>' >> "$UPDATES_XML"
                  echo '</updates>' >> "$UPDATES_XML"
                fi
                if [ -f "$UPDATES_XML" ]; then
                  cp "$UPDATES_XML" "${UPDATES_XML}.bak"
                  # Update version
                  sed -i "s|<version>.*</version>|<version>${{ steps.set_version.outputs.version }}</version>|g" "$UPDATES_XML"
                  # Update download URL
                  sed -i "s|<downloadurl.*>.*</downloadurl>|<downloadurl type=\"full\" format=\"zip\">$DOWNLOAD_URL</downloadurl>|g" "$UPDATES_XML"
                  # Remove backup file
                  rm -f "${UPDATES_XML}.bak"
                  echo "Updated $UPDATES_XML file with new version and download URL"
                  cat "$UPDATES_XML"
                else
                  echo "::warning::${{ inputs.updates-xml-file }} file could not be created."
                fi

        -   name: Update PHP files
            if: inputs.file-updates == 'true'
            shell: bash
            run: |
                # Function to update PHP files in a directory
                update_php_files() {
                  local SEARCH_DIR="$1"
                  find "$SEARCH_DIR" -name "*.php" | while read -r PHP_FILE; do
                    if [ -f "$PHP_FILE" ]; then
                      if grep -q "@version" "$PHP_FILE"; then
                        sed -i -E "s|(@version[ ]+).*|\\1${{ steps.set_version.outputs.version }}|g" "$PHP_FILE"
                        sed -i -E "s|(Version[ ]*:[ ]*).*|\\1${{ steps.set_version.outputs.version }}|g" "$PHP_FILE"
                        sed -i -E "s|(\* Version:)[0-9]{4}\.[0-9]{2}\.[0-9]{2}|\\1${{ steps.set_version.outputs.version }}|g" "$PHP_FILE"
                        sed -i "s|@copyright.*|@copyright Copyright (C) ${{ steps.set_version.outputs.current_year }} ${{ inputs.copyright-holder }}|g" "$PHP_FILE"
                      fi
                    fi
                  done
                }
                
                # Update PHP files in main directory
                update_php_files "."
                
                # If this is a package, also update PHP files in referenced extensions
                EXTENSION_XML="${{ steps.extension_details.outputs.extension_xml }}"
                if [ -f "$EXTENSION_XML" ] && grep -q 'type="package"' "$EXTENSION_XML"; then
                  echo "Package extension detected. Updating PHP files in referenced extensions..."
                  
                  # Extract the directories from the <file> tags
                  REFERENCED_DIRS=$(grep -oP '<file[^>]*>\K[^<]+(?=</file>)' "$EXTENSION_XML")
                  
                  if [ -n "$REFERENCED_DIRS" ]; then
                    for REF_DIR in $REFERENCED_DIRS; do
                      if [ -d "$REF_DIR" ]; then
                        echo "Updating PHP files in: $REF_DIR"
                        update_php_files "$REF_DIR"
                      fi
                    done
                  fi
                fi

        -   name: Update language files
            if: inputs.file-updates == 'true'
            shell: bash
            run: |
                # Function to update language files in a directory
                update_lang_files() {
                  local SEARCH_DIR="$1"
                  find "$SEARCH_DIR" -name "*.ini" -o -name "*.sys.ini" | while read -r LANG_FILE; do
                    if [ -f "$LANG_FILE" ]; then
                      if [ "${{ steps.set_version.outputs.current_year }}" -gt "${{ inputs.copyright-start-year }}" ]; then
                        sed -i "s|; Copyright (C) [0-9]\{4\} - [0-9]\{4\} ${{ inputs.copyright-holder }}|; Copyright (C) ${{ inputs.copyright-start-year }} - ${{ steps.set_version.outputs.current_year }} ${{ inputs.copyright-holder }}|g" "$LANG_FILE"
                        sed -i "s|; Copyright (C) [0-9]\{4\} ${{ inputs.copyright-holder }}|; Copyright (C) ${{ inputs.copyright-start-year }} - ${{ steps.set_version.outputs.current_year }} ${{ inputs.copyright-holder }}|g" "$LANG_FILE"
                      else
                        sed -i "s|; Copyright (C) [0-9]\{4\} - [0-9]\{4\} ${{ inputs.copyright-holder }}|; Copyright (C) ${{ steps.set_version.outputs.current_year }} ${{ inputs.copyright-holder }}|g" "$LANG_FILE"
                        sed -i "s|; Copyright (C) [0-9]\{4\} ${{ inputs.copyright-holder }}|; Copyright (C) ${{ steps.set_version.outputs.current_year }} ${{ inputs.copyright-holder }}|g" "$LANG_FILE"
                      fi
                    fi
                  done
                }
                
                # Update language files in main directory
                update_lang_files "."
                
                # If this is a package, also update language files in referenced extensions
                EXTENSION_XML="${{ steps.extension_details.outputs.extension_xml }}"
                if [ -f "$EXTENSION_XML" ] && grep -q 'type="package"' "$EXTENSION_XML"; then
                  echo "Package extension detected. Updating language files in referenced extensions..."
                  
                  # Extract the directories from the <file> tags
                  REFERENCED_DIRS=$(grep -oP '<file[^>]*>\K[^<]+(?=</file>)' "$EXTENSION_XML")
                  
                  if [ -n "$REFERENCED_DIRS" ]; then
                    for REF_DIR in $REFERENCED_DIRS; do
                      if [ -d "$REF_DIR" ]; then
                        echo "Updating language files in: $REF_DIR"
                        update_lang_files "$REF_DIR"
                      fi
                    done
                  fi
                fi

        -   name: Update CSS files
            if: inputs.file-updates == 'true'
            shell: bash
            run: |
                # Function to update CSS files in a directory
                update_css_files() {
                  local SEARCH_DIR="$1"
                  find "$SEARCH_DIR" -name "*.css" | while read -r CSS_FILE; do
                    if [ -f "$CSS_FILE" ]; then
                      if grep -q "Copyright (C)" "$CSS_FILE"; then
                        if [ "${{ steps.set_version.outputs.current_year }}" -gt "${{ inputs.copyright-start-year }}" ]; then
                          sed -i "s|/\* Copyright (C) [0-9]\{4\} ${{ inputs.copyright-holder }} \*/|/* Copyright (C) ${{ inputs.copyright-start-year }} - ${{ steps.set_version.outputs.current_year }} ${{ inputs.copyright-holder }} */|g" "$CSS_FILE"
                          sed -i "s|/\* Copyright (C) [0-9]\{4\} - [0-9]\{4\} ${{ inputs.copyright-holder }} \*/|/* Copyright (C) ${{ inputs.copyright-start-year }} - ${{ steps.set_version.outputs.current_year }} ${{ inputs.copyright-holder }} */|g" "$CSS_FILE"
                          sed -i "s| \* Copyright (C) [0-9]\{4\} ${{ inputs.copyright-holder }}| * Copyright (C) ${{ inputs.copyright-start-year }} - ${{ steps.set_version.outputs.current_year }} ${{ inputs.copyright-holder }}|g" "$CSS_FILE"
                          sed -i "s| \* Copyright (C) [0-9]\{4\} - [0-9]\{4\} ${{ inputs.copyright-holder }}| * Copyright (C) ${{ inputs.copyright-start-year }} - ${{ steps.set_version.outputs.current_year }} ${{ inputs.copyright-holder }}|g" "$CSS_FILE"
                        else
                          sed -i "s|/\* Copyright (C) [0-9]\{4\} ${{ inputs.copyright-holder }} \*/|/* Copyright (C) ${{ steps.set_version.outputs.current_year }} ${{ inputs.copyright-holder }} */|g" "$CSS_FILE"
                          sed -i "s|/\* Copyright (C) [0-9]\{4\} - [0-9]\{4\} ${{ inputs.copyright-holder }} \*/|/* Copyright (C) ${{ steps.set_version.outputs.current_year }} ${{ inputs.copyright-holder }} */|g" "$CSS_FILE"
                          sed -i "s| \* Copyright (C) [0-9]\{4\} ${{ inputs.copyright-holder }}| * Copyright (C) ${{ steps.set_version.outputs.current_year }} ${{ inputs.copyright-holder }}|g" "$CSS_FILE"
                          sed -i "s| \* Copyright (C) [0-9]\{4\} - [0-9]\{4\} ${{ inputs.copyright-holder }}| * Copyright (C) ${{ steps.set_version.outputs.current_year }} ${{ inputs.copyright-holder }}|g" "$CSS_FILE"
                        fi
                      fi
                  
                      if grep -q "\* Version:[0-9]\{4\}\.[0-9]\{2\}\.[0-9]\{2\}" "$CSS_FILE"; then
                        sed -i -E "s|(\* Version:)[0-9]{4}\.[0-9]{2}\.[0-9]{2}|\\1${{ steps.set_version.outputs.version }}|g" "$CSS_FILE"
                      fi
                    fi
                  done
                }
                
                # Update CSS files in main directory
                update_css_files "."
                
                # If this is a package, also update CSS files in referenced extensions
                EXTENSION_XML="${{ steps.extension_details.outputs.extension_xml }}"
                if [ -f "$EXTENSION_XML" ] && grep -q 'type="package"' "$EXTENSION_XML"; then
                  echo "Package extension detected. Updating CSS files in referenced extensions..."
                  
                  # Extract the directories from the <file> tags
                  REFERENCED_DIRS=$(grep -oP '<file[^>]*>\K[^<]+(?=</file>)' "$EXTENSION_XML")
                  
                  if [ -n "$REFERENCED_DIRS" ]; then
                    for REF_DIR in $REFERENCED_DIRS; do
                      if [ -d "$REF_DIR" ]; then
                        echo "Updating CSS files in: $REF_DIR"
                        update_css_files "$REF_DIR"
                      fi
                    done
                  fi
                fi

        -   name: Generate changelog
            if: inputs.generate-changelog == 'true'
            id: changelog
            shell: bash
            run: |
                PREVIOUS_TAG=$(git describe --tags --abbrev=0 --always $(git rev-list --tags --skip=1 --max-count=1) 2>/dev/null || echo "")
                CURRENT_DATE=$(date -u +"%Y-%m-%d")
                
                ADDED=""
                CHANGED=""
                FIXED=""
                REMOVED=""
                SECURITY=""
                
                if [ -z "$PREVIOUS_TAG" ]; then
                  COMMITS=$(git log --pretty=format:"%s|%h" --reverse)
                else
                  COMMITS=$(git log --pretty=format:"%s|%h" ${PREVIOUS_TAG}..HEAD --reverse)
                fi
                
                while IFS= read -r line; do
                  COMMIT_MSG=$(echo "$line" | cut -d'|' -f1)
                  COMMIT_HASH=$(echo "$line" | cut -d'|' -f2)
                
                  if [[ "$COMMIT_MSG" =~ ^(Add|Create|Implement|Feature) ]]; then
                    ADDED="$ADDED\n* $COMMIT_MSG ([${COMMIT_HASH}](https://github.com/${{ github.repository }}/commit/${COMMIT_HASH}))"
                  elif [[ "$COMMIT_MSG" =~ ^(Update|Improve|Enhance|Refactor|Change) ]]; then
                    CHANGED="$CHANGED\n* $COMMIT_MSG ([${COMMIT_HASH}](https://github.com/${{ github.repository }}/commit/${COMMIT_HASH}))"
                  elif [[ "$COMMIT_MSG" =~ ^(Fix|Bug|Correct|Resolve) ]]; then
                    FIXED="$FIXED\n* $COMMIT_MSG ([${COMMIT_HASH}](https://github.com/${{ github.repository }}/commit/${COMMIT_HASH}))"
                  elif [[ "$COMMIT_MSG" =~ ^(Remove|Delete|Deprecate) ]]; then
                    REMOVED="$REMOVED\n* $COMMIT_MSG ([${COMMIT_HASH}](https://github.com/${{ github.repository }}/commit/${COMMIT_HASH}))"
                  elif [[ "$COMMIT_MSG" =~ ^(Security) ]]; then
                    SECURITY="$SECURITY\n* $COMMIT_MSG ([${COMMIT_HASH}](https://github.com/${{ github.repository }}/commit/${COMMIT_HASH}))"
                  else
                    CHANGED="$CHANGED\n* $COMMIT_MSG ([${COMMIT_HASH}](https://github.com/${{ github.repository }}/commit/${COMMIT_HASH}))"
                  fi
                done <<< "$COMMITS"
                
                # Create changelog file
                echo "# Changelog" > ${{ inputs.changelog-file }}
                echo "" >> ${{ inputs.changelog-file }}
                echo "All notable changes to this project will be documented in this file." >> ${{ inputs.changelog-file }}
                echo "" >> ${{ inputs.changelog-file }}
                echo "The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)," >> ${{ inputs.changelog-file }}
                echo "and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html)." >> ${{ inputs.changelog-file }}
                echo "" >> ${{ inputs.changelog-file }}
                echo "## [${{ steps.set_version.outputs.version }}] - $CURRENT_DATE" >> ${{ inputs.changelog-file }}
                echo "" >> ${{ inputs.changelog-file }}
                
                if [ ! -z "$ADDED" ]; then echo "### Added" >> ${{ inputs.changelog-file }}; echo -e "$ADDED" >> ${{ inputs.changelog-file }}; echo "" >> ${{ inputs.changelog-file }}; fi
                if [ ! -z "$CHANGED" ]; then echo "### Changed" >> ${{ inputs.changelog-file }}; echo -e "$CHANGED" >> ${{ inputs.changelog-file }}; echo "" >> ${{ inputs.changelog-file }}; fi
                if [ ! -z "$FIXED" ]; then echo "### Fixed" >> ${{ inputs.changelog-file }}; echo -e "$FIXED" >> ${{ inputs.changelog-file }}; echo "" >> ${{ inputs.changelog-file }}; fi
                if [ ! -z "$REMOVED" ]; then echo "### Removed" >> ${{ inputs.changelog-file }}; echo -e "$REMOVED" >> ${{ inputs.changelog-file }}; echo "" >> ${{ inputs.changelog-file }}; fi
                if [ ! -z "$SECURITY" ]; then echo "### Security" >> ${{ inputs.changelog-file }}; echo -e "$SECURITY" >> ${{ inputs.changelog-file }}; echo "" >> ${{ inputs.changelog-file }}; fi
                
                # Output for release notes
                CHANGELOG_OUTPUT=""
                if [ ! -z "$ADDED" ]; then CHANGELOG_OUTPUT="${CHANGELOG_OUTPUT}### Added\n${ADDED}\n\n"; fi
                if [ ! -z "$CHANGED" ]; then CHANGELOG_OUTPUT="${CHANGELOG_OUTPUT}### Changed\n${CHANGED}\n\n"; fi
                if [ ! -z "$FIXED" ]; then CHANGELOG_OUTPUT="${CHANGELOG_OUTPUT}### Fixed\n${FIXED}\n\n"; fi
                if [ ! -z "$REMOVED" ]; then CHANGELOG_OUTPUT="${CHANGELOG_OUTPUT}### Removed\n${REMOVED}\n\n"; fi
                if [ ! -z "$SECURITY" ]; then CHANGELOG_OUTPUT="${CHANGELOG_OUTPUT}### Security\n${SECURITY}\n\n"; fi
                
                echo "changelog<<EOF" >> $GITHUB_OUTPUT
                echo -e "$CHANGELOG_OUTPUT" >> $GITHUB_OUTPUT
                echo "EOF" >> $GITHUB_OUTPUT

        -   name: Cleanup repo files
            if: always()
            shell: bash
            run: |
                # Remove all .bak files recursively
                find . -name "*.bak" -type f -delete
                
                # Remove directory structure file if it exists
                rm -f directory-structure.txt
                
                echo "Removed all backup files and temporary files from repository"

        -   name: Create package
            id: create_package
            shell: bash
            run: |
                EXTENSION_NAME="${{ steps.extension_details.outputs.extension_name }}"
                VERSION="${{ steps.set_version.outputs.version }}"

                if [ -n "$RUNNER_TEMP" ]; then
                  OUTER_BUILD_DIR="$RUNNER_TEMP/joomla-build-$EXTENSION_NAME-$VERSION"
                else
                  OUTER_BUILD_DIR="/tmp/joomla-build-$EXTENSION_NAME-$VERSION"
                fi
                rm -rf "$OUTER_BUILD_DIR"
                mkdir -p "$OUTER_BUILD_DIR"

                EXCLUDES=(
                  --exclude='.git/'
                  --exclude='.github/'
                  --exclude='.DS_Store'
                  --exclude='Thumbs.db'
                  --exclude='node_modules/'
                  --exclude='.packagerignore'
                  --exclude='build/'
                  --exclude='package/'
                  --exclude='.gitignore'
                  --exclude='*.bak'
                  --exclude='*.zip'
                )
                # Exclude README.md unless readme input is true
                if [ "${{ inputs.readme }}" != "true" ]; then
                  EXCLUDES+=(--exclude='README.md')
                fi
                if [ -f .packagerignore ]; then
                  while IFS= read -r line; do
                    [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue
                    EXCLUDES+=(--exclude="$line")
                  done < .packagerignore
                fi
                
                rsync -a ./ "$OUTER_BUILD_DIR/" "${EXCLUDES[@]}"

                # Generate directory tree from OUTER_BUILD_DIR
                if [ -n "${{ inputs.dir-tree-file }}" ]; then
                  DIR_TREE_PATH="$OUTER_BUILD_DIR/${{ inputs.dir-tree-file }}"
                  if command -v tree &> /dev/null; then
                    (cd "$OUTER_BUILD_DIR" && tree -a -F . | sed '1s|^\./\?$|/|') > "$DIR_TREE_PATH"
                  else
                    find "$OUTER_BUILD_DIR" -type f | sed "s|^$OUTER_BUILD_DIR|/|" | sort > "$DIR_TREE_PATH"
                  fi
                  echo "dir_tree_path=$DIR_TREE_PATH" >> $GITHUB_OUTPUT
                fi

                echo "Contents of OUTER_BUILD_DIR before artifact upload:"
                ls -l "$OUTER_BUILD_DIR"
                echo "package_path=$OUTER_BUILD_DIR" >> $GITHUB_OUTPUT

        -   name: Debug package_path before upload
            shell: bash
            run: |
                echo "package_path is: ${{ steps.create_package.outputs.package_path }}"
                ls -l "${{ steps.create_package.outputs.package_path }}" || echo "Directory not found"

        -   name: Upload extension package files
            if: inputs.upload-artifact == 'true'
            uses: actions/upload-artifact@v4
            with:
                name: ${{ steps.extension_details.outputs.extension_name }}_${{ steps.set_version.outputs.version }}
                path: ${{ steps.create_package.outputs.package_path }}
                retention-days: 90
                if-no-files-found: warn

        -   name: Debug tag for release
            shell: bash
            run: |
                echo "DEBUG: tag_name is ${{ steps.set_version.outputs.version }}"

        -   name: Debug set_version output
            shell: bash
            run: |
                echo "DEBUG: set_version.outputs.version is ${{ steps.set_version.outputs.version }}"

        -   name: Create release zip for GitHub Release
            if: inputs.create-release == 'true'
            shell: bash
            run: |
                EXTENSION_NAME="${{ steps.extension_details.outputs.extension_name }}"
                VERSION="${{ steps.set_version.outputs.version }}"
                if [ -n "$RUNNER_TEMP" ]; then
                  OUTER_BUILD_DIR="$RUNNER_TEMP/joomla-build-$EXTENSION_NAME-$VERSION"
                else
                  OUTER_BUILD_DIR="/tmp/joomla-build-$EXTENSION_NAME-$VERSION"
                fi
                ZIP_PATH="${OUTER_BUILD_DIR}/../${EXTENSION_NAME}_${VERSION}.zip"
                cd "$OUTER_BUILD_DIR"
                zip -r "$ZIP_PATH" .
                cd -
                echo "ZIP_PATH=$ZIP_PATH" >> $GITHUB_ENV

        -   name: Create GitHub Release
            if: inputs.create-release == 'true'
            shell: bash
            run: |
                TAG_NAME="${{ steps.set_version.outputs.version }}"
                RELEASE_NAME="${{ steps.set_version.outputs.version }} Release"
                ZIP_PATH="$ZIP_PATH"
                DIR_TREE_PATH="${{ steps.create_package.outputs.dir_tree_path }}"
                echo "Creating GitHub Release with tag: $TAG_NAME"
                echo "ZIP: $ZIP_PATH"
                echo "DIR TREE: ${{ steps.create_package.outputs.dir_tree_path }}"
                gh release create "$TAG_NAME" "$ZIP_PATH" "${{ steps.create_package.outputs.dir_tree_path }}" --title "$RELEASE_NAME" --notes "Automated release by workflow" || gh release upload "$TAG_NAME" "$ZIP_PATH" "${{ steps.create_package.outputs.dir_tree_path }}" --clobber
            env:
                GITHUB_TOKEN: ${{ inputs.github-token }}
